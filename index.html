<!doctype html>
<html><head><title>Super Outliner</title>
<!-- <link rel="stylesheet" href="common.css"> -->
<style type="text/css">
.outlines {position:relative;}
.prototype, .dead {display:none !important;}
.item {margin:1ex 0 1ex; display:block;}
.title {font-weight:bold; height:1em;}
.note { height:1em; font-size:.8em; border-top:0;}
textarea {line-height:1em; border:1px solid #ccc; display:block; width:100%;
  font-family:inherit; font-size:inherit; margin:0; max-width:500pt;}


.folded .contents {display:none;}
.folded {border-bottom:1px dashed gray; padding-bottom:2px; }
.controls {-webkit-column-width:15em; -moz-column-width:15em;}

.title {-webkit-border-radius:4pt 4pt 0 0; -moz-border-radius:4pt 4pt 0 0;}
.note  {-webkit-border-radius:0 0 4pt 4pt; -moz-border-radius:0 0 4pt 4pt;}
.title, .note {padding:2pt;}
.title {padding-bottom:0;}
.note {padding-top:0;}
</style>

<script src="jquery-1.3.2.js"></script>
<script src="jquery.autogrow.js"></script>
<script type="text/javascript">
// Undo + Persistence
var events = []
var undone_events = []
var history_event = false

$(document).ready(function(){
  var keys = {enter:13, tab:9, up:38, down:40, left:37, right:39, del:8}
  
  function create_history_item(data){
    events.push(data)
    // $('.output').text(data.toSource())
    if (!history_event) undone_events = []
    // Doing real events destroys undone events. How sad.
  }
  
  function changed_text(event){
    var field = $(this)
    var old_text = field.attr("data-text")
    var new_text = field.val()
    if (old_text != new_text){
      field.attr("data-text", new_text)
      create_history_item({type:'change', field:field, old_text:old_text, new_text:new_text})      
    }
  }
  
  function create_item(insert){
    var node = $('.item.prototype').clone().removeClass('prototype')
    insert(node)
    $(':focus').blur()
    node.find('.note').keydown(note_keydown).change(changed_text).autogrow({extraSpace:100}).blur(changed_text)
    node.find('.title').keydown(title_keydown).focus().blur(changed_text)
    create_history_item({type:'create', item:node})
    return false
  }

  function indent(item){
    var prev = item.prev()
    if (prev.length && !prev.hasClass('folded')){
      item.appendTo(prev.find('.contents:first'))
      focus_item(item)
      create_history_item({type:'indent', item:item})
    }
  }
  
  function dedent(item){
    var parent = item.parents('.item:first')
    if (parent.length){
      parent.after(item)
      focus_item(item)
      create_history_item({type:'dedent', item:item})
    }
  }

  function focus_item(item){
    if (item.length) $(':focus').blur()
    return item.find('.title:first').focus()
  }

  function focus_prev(item){
    var prev = item.prev('.item:first') // find prev sibling
    if (prev.length) {
      while (true){
        if (prev.hasClass('folded')) break
        var child = prev.find('.contents:first > .item:last')
        if (!child.length) break // give up
        prev = child
      }
      // // oh crap, still folding issues here.
      // var child = prev.find('.item:last') // prefer sibling's last x-child
      // if (child.length && !prev.hasClass('folded')) prev = child
    }
    if (!prev.length){
      prev = item.parents('.item:first') // settle for own parent
    }
    return focus_item(prev)
  }
  
  function focus_next(item){
    var next
    if (!item.hasClass('.folded')) next = item.find('.item:first') // prefer first child
    if (!next || !next.length) next = item.next() // settle for next sibling
    if (!next.length) { // settle for x-parent's next sibling
      next = item
      while (true){
        next = next.parents('.item:first')
        if (!next.length) break // no solution
        var neighbor = next.next()
        if (neighbor.length){
          next = neighbor // found it
          break
        }
      }
    }
    return focus_item(next)    
  }
    
  function move_up(item){
    var prev = item.prev()
    if (prev.length) prev.before(item)
    // else { // re-parent?  Is this useful?
    //   
    // }
    focus_item(item)
    create_history_item({type:'move_up', item:item})
  }

  function move_down(item){
    item.next().after(item)
    focus_item(item)
    create_history_item({type:'move_down', item:item})
  }
  
  function delete_tree(item){
    focus_prev(item).length || focus_item(item.next()).length
    var prev = item.prev()
    var parent
    if (!prev.length) parent = item.parents('.contents:first')
    item.prependTo($('.dead'))
    create_history_item({type:'delete_tree', item:item, prev:prev, parent:parent})

    if(!$('.outlines .item').length) init_empty()
    // unfortunately, this can create a lot of useless nodes in the history...
    // but you'd need a blank outline for that to happen anyway.  Hurr.  What's the right thing to do?

    // } else {  // can't delete last node
    //   item.find('.title, .note').val('')
    //   item.find('.item').remove()
    //   item.removeClass('folded')
    //   create_history_item({type:'clear', item:item})
    //   // okay now I really need to fix this problem.
    //   // should reall get rid of this special case and just do a re-create node if necessary...
    // }
  }
  
  function delete_reparent(item){
    var children = item.find('.contents:first > .item')
    var parent = item.parents('.item:first')
    if (parent.length){
      parent.find('.contents:first').append(children)
      item.remove()
      focus_item(parent)
      events.push({type:'delete_reparent', item:item})
    }
  }
  
  function fold(item){
    item.addClass('folded')
    create_history_item({type:'fold', item:item})    
  }
  
  function unfold(item){
    item.removeClass('folded')
    create_history_item({type:'unfold', item:item})    
  }

  function toggle_fold_item(item){
    if (item.find('.item').length){
      if (item.hasClass('folded'))  unfold(item)
      else                          fold(item)
    }
  }

  function note_keydown(event){
    if(event.which == keys.enter){
      if (event.shiftKey){
        stop(event)
        var item = $(this).parents('.item:first')
        focus_item(item)
      }
    }
  }

  function title_keydown(event){
    var item = $(this).parents('.item:first')

    if(event.which == keys.enter){
      stop(event)
      if      (event.shiftKey)  {
        $(':focus').blur()
        item.find('.note').focus()
      } 
      else if (event.altKey)    return toggle_fold_item(item)
      else                      return create_item(function(node){ item.after(node) })

    } else if (event.which == keys.tab){
      stop(event)
      if (!event.shiftKey)      return indent(item)
      else                      return dedent(item)

    } else if (event.which == keys.up){
      stop(event)
      if      (event.shiftKey)  return move_up(item)
      else if (event.altKey)    return focus_item(item.prev())
      else                      return focus_prev(item)

    } else if (event.which == keys.down){
      stop(event)
      if      (event.shiftKey)  return move_down(item)
      else if (event.altKey)    return focus_item(item.next())
      else                      return focus_next(item)

    } else if (event.which == keys.right && event.shiftKey) {
      stop(event)
                                return indent(item)

    } else if (event.which == keys.left && event.shiftKey) {
      stop(event)
                                return dedent(item)
    
    } else if (event.which == keys.del && ($(this).val() == "" || event.ctrlKey || event.altKey)) {
      stop(event)
      // if (event.altKey)         reparenting_delete(item)
      // else                      
                                return delete_tree(item)
    }
  }
  
  function stop(event){
    event.preventDefault()
    faniggle_text()
    // event.stopPropagation()
  }
  
  function window_keydown(event){
    if (event.which == keys.enter){
      if ($(':focus').length) return // only act when nothing is focused
      stop(event)
      create_item(function(item){ item.appendTo($('.outlines')) })
    
    } else if (event.which == keys.left && event.altKey) {
      stop(event)
      return undo()
    
    } else if (event.which == keys.right && event.altKey) {
      stop(event)
      return redo()
    }
  }
  
  $(window).keydown(window_keydown)
  
  
  var reverse_event = {
    create:     function(data){ delete_tree (data.item) },
    indent:     function(data){ dedent      (data.item) },
    dedent:     function(data){ indent      (data.item) },
    move_up:    function(data){ move_down   (data.item) },
    move_down:  function(data){ move_up     (data.item) },
    fold:       function(data){ unfold      (data.item) },
    unfold:     function(data){ fold        (data.item) },
    delete_tree:function(data){ // restore from purgatory
        if (data.prev.length) data.prev.after(data.item)
        else data.parent.prepend(data.item)
        focus_item(data.item)
        create_history_item({type:'create', item:data.item})
      },
    delete_rebase:function(data){
      
    },
    delete_reparent:function(data){
      // damn, this one might be difficult
    },
    change: function(data){
      data.field.val(data.old_text)
      data.field.attr('data-text', data.old_text)
      data.field.focus()
      create_history_item({type:'change', field:data.field, old_text:data.new_text, new_text:data.old_text})
    }
  }
  
  function faniggle_text(){
    var field = $(':focus')
    field.blur()
    field.focus()
  }
  
  function undo(){
    // quick hack for text editing
    faniggle_text()    
    
    if (events.length) {
      history_event = true
      var event = events.pop()
      reverse_event[event.type](event)
      undone_events.push(events.pop())
      history_event = false
    }
  }

  function redo(){
    if (undone_events.length) {
      history_event = true
      var event = undone_events.pop()
      reverse_event[event.type](event)
      history_event = false
    }
  }

  function init_empty(){
    create_item(function(node){ node.appendTo('.outlines') })
    events.pop()
  }
  
  init_empty()
  
})
</script>


</head><body>
  <ul class="controls">
    <li>Enter: New Sibling
    <li>Shift+Enter: Edit Note/Title
    <li>Alt+Enter: Fold/Unfold
    <li>Alt+Backspace: Delete Tree
    <!-- <li>Alt+Backspace: Delete -->
    <li>Up/Down: Navigate Tree
    <li>Alt+Up/Down: Navigate Siblings
    <li>Shift+Arrows: Move
    <li>Alt+Left/Right: Undo/Redo
  </ul>
<!-- <div class="notify"></div> -->

<div class="output">
  </div>

<ul class="outlines contents">
  
</ul>

<ul class="dead">
</ul>

<li class="item prototype">
  <textarea class="title" data-text=""></textarea>
  <textarea class="note" data-text=""></textarea>
  <ul class="contents"></ul>
</li>

</body></html>